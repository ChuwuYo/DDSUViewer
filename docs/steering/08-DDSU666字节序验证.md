# DDSU666 字节序验证报告

## 验证背景

通过实际设备测试，验证了DDSU666电能表的IEEE754浮点数字节序格式。

## 测试结果

### 原始测试数据
```
原始数据: 43 5C 80 00
```

### 不同字节序解析结果
```
标准大端序: 220.500000  ← 正确！
字交换小端序: 0.000012
完全小端序: 0.000000
字交换大端序: 188.000000
```

## 验证分析

### 1. 标准大端序解析 (正确)
- **原始数据**: `43 5C 80 00`
- **解析结果**: `220.5V`
- **验证**: 符合中国市电标准220V±10%，完全合理

### 2. IEEE754验证
220.5的IEEE754标准表示：
- **二进制**: `0 10000110 10111001000000000000000`
- **十六进制**: `43 5C 80 00`
- **符号位**: 0 (正数)
- **指数**: 10000110 (134, 实际指数=134-127=7)
- **尾数**: 10111001000000000000000 (1.10111001)

### 3. 其他解析方式错误原因
- **字交换小端序**: 错误地交换了字节顺序，破坏了IEEE754格式
- **完全小端序**: 完全反转字节顺序，与大端设备不兼容
- **字交换大端序**: 不必要的字节交换，得到错误数值

## 结论

### 确认的字节序格式
DDSU666电能表使用**IEEE 754标准大端序格式**：
- 寄存器高位在前
- 每个寄存器内高字节在前
- 直接按大端序解析32位浮点数

### 代码修正
```go
// 修正前 (错误)
func ParseFloat32(data []byte) float32 {
    bytes := make([]byte, 4)
    bytes[0] = data[1] // 错误的字节交换
    bytes[1] = data[0]
    bytes[2] = data[3]
    bytes[3] = data[2]
    bits := binary.LittleEndian.Uint32(bytes)
    return math.Float32frombits(bits)
}

// 修正后 (正确)
func ParseFloat32(data []byte) float32 {
    bits := binary.BigEndian.Uint32(data) // 标准大端序
    return math.Float32frombits(bits)
}
```

### 文档更新
- 更新技术文档中的字节序说明
- 移除"字交换小端序"的错误描述
- 明确标注使用"IEEE 754标准大端序"

## 建议

1. **立即应用修正**: 将所有浮点数解析改为标准大端序
2. **验证其他参数**: 确认电流、功率等参数也使用相同格式
3. **更新文档**: 修正所有相关技术文档
4. **测试验证**: 在实际设备上验证修正后的数据准确性

## 测试环境

- **设备型号**: DDSU666单相电子式电能表
- **通信协议**: Modbus RTU
- **测试电压**: 约220V市电
- **验证方法**: 多种字节序对比分析