# DDSUViewer 前端技术实现

## 前端架构概述

DDSUViewer 前端采用现代化的 React 技术栈，结合 TypeScript 提供类型安全，使用 Chakra UI v3 构建现代化的用户界面。整体架构遵循组件化设计原则，通过状态管理实现数据的统一管理和分发。

## 技术栈详情

### 核心技术
- **React 18**: 现代化前端框架，支持并发特性
- **TypeScript**: 提供静态类型检查和更好的开发体验
- **Chakra UI v3**: 现代化 UI 组件库，基于 Material Design 3
- **Vite**: 快速的前端构建工具和开发服务器

### 依赖库
```json
{
  "dependencies": {
    "@chakra-ui/react": "^3.26.0",
    "@chakra-ui/theme-tools": "^2.2.6", 
    "@emotion/react": "^11.14.0",
    "@emotion/styled": "^11.14.1",
    "framer-motion": "^12.23.12",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  }
}
```

## 项目结构

```
frontend/
├── public/
│   └── appicon.png              # 应用图标
├── src/
│   ├── components/              # React 组件
│   │   ├── ElectricalDataPanel.tsx
│   │   ├── SerialConfigPanel.tsx
│   │   └── StatusPanel.tsx
│   ├── hooks/                   # 自定义 Hooks
│   │   └── usePolling.ts
│   ├── store/                   # 状态管理
│   │   └── appStore.ts
│   ├── theme/                   # 主题配置
│   │   └── colors.ts
│   ├── App.tsx                  # 主应用组件
│   ├── main.tsx                 # 应用入口
│   └── style.css               # 全局样式
├── wailsjs/                    # Wails 生成的绑定文件
│   ├── go/main/
│   │   ├── App.d.ts
│   │   └── App.js
│   └── runtime/
├── index.html
├── package.json
├── tsconfig.json
└── vite.config.ts
```

## 核心组件设计

### 1. 主应用组件 (App.tsx)

```typescript
function App() {
  return (
    <Box minH="100vh" bg={mdColors.background}>
      {/* 顶部标题栏 */}
      <Box bg={mdColors.surface} shadow="md" borderBottom="1px" borderColor={mdColors.outlineVariant}>
        <Box maxW="7xl" mx="auto" px={6} py={4}>
          <Flex align="center">
            <Flex align="center" gap={3}>
              <Image src="/appicon.png" alt="DDSU666 Logo" boxSize="32px" />
              <Box>
                <Flex align="baseline" gap={2}>
                  <Text fontSize="xl" fontWeight="800" color={mdColors.primary}>
                    DDSU666
                  </Text>
                  <Text fontSize="lg" fontWeight="500" color={mdColors.onSurfaceVariant}>
                    电能表上位机
                  </Text>
                </Flex>
              </Box>
            </Flex>
            <Spacer />
            <Badge bg={mdColors.secondaryContainer} color={mdColors.onSecondaryContainer}>
              在线监控
            </Badge>
          </Flex>
        </Box>
      </Box>

      {/* 主要内容区域 */}
      <Box maxW="7xl" mx="auto" p={6}>
        <Grid templateColumns={{ base: "1fr", lg: "2fr 1fr" }} gap={6}>
          <GridItem>
            <ElectricalDataPanel />
          </GridItem>
          <GridItem>
            <Flex direction="column" gap={6} h="full">
              <StatusPanel />
              <SerialConfigPanel />
            </Flex>
          </GridItem>
        </Grid>
      </Box>
    </Box>
  );
}
```

**设计特点**:
- 响应式布局设计，适配不同屏幕尺寸
- Material Design 3 色彩系统
- 清晰的信息层次结构
- 现代化的视觉设计

### 2. 电参量数据面板 (ElectricalDataPanel.tsx)

```typescript
const DataCard = ({ title, value, unit, color = 'blue' }: {
  title: string;
  value?: number;
  unit: string;
  color?: string;
}) => (
  <Card.Root 
    bg={mdColors.cardBackground} 
    shadow="md" 
    borderRadius="xl" 
    border="1px" 
    borderColor={mdColors.outlineVariant}
    _hover={{ shadow: "lg", transform: "translateY(-2px)" }}
    transition="all 0.2s"
  >
    <Card.Body p={6}>
      <Text fontSize="sm" color={mdColors.onSurfaceVariant} mb={2} fontWeight="medium">
        {title}
      </Text>
      <Text 
        fontSize="3xl" 
        fontWeight="bold" 
        color={value !== undefined ? dataColors[color] : mdColors.outline} 
        mb={1}
      >
        {value !== undefined ? value.toFixed(3) : '未知'}
      </Text>
      <Text fontSize="sm" color={mdColors.onSurfaceVariant} fontWeight="medium">
        {unit}
      </Text>
    </Card.Body>
  </Card.Root>
);

export const ElectricalDataPanel = () => {
  const { data: electricalData } = useAppStore();

  return (
    <Box bg={mdColors.surface} borderRadius="xl" shadow="md" p={6}>
      <Flex mb={6} align="center" justify="space-between">
        <Text fontSize="xl" fontWeight="bold" color={mdColors.onSurface}>
          实时电参量数据
        </Text>
        <Badge bg={mdColors.secondaryContainer} color={mdColors.onSecondaryContainer}>
          实时更新
        </Badge>
      </Flex>
      
      <SimpleGrid columns={{ base: 2, lg: 4 }} gap={6}>
        <DataCard title="电压" value={electricalData?.voltage} unit="V" color="blue" />
        <DataCard title="电流" value={electricalData?.current} unit="A" color="orange" />
        <DataCard title="有功功率" value={electricalData?.activePower} unit="W" color="green" />
        <DataCard title="无功功率" value={electricalData?.reactivePower} unit="Var" color="purple" />
        <DataCard title="视在功率" value={electricalData?.apparentPower} unit="VA" color="teal" />
        <DataCard title="功率因数" value={electricalData?.powerFactor} unit="" color="cyan" />
        <DataCard title="频率" value={electricalData?.frequency} unit="Hz" color="pink" />
        <DataCard title="有功总电能" value={electricalData?.activeEnergy} unit="kWh" color="red" />
      </SimpleGrid>
    </Box>
  );
};
```

**设计特点**:
- 卡片式数据展示，清晰直观
- 响应式网格布局
- 悬停动画效果
- 数据状态指示 (有数据/无数据)
- 彩色编码便于区分不同参数

### 3. 串口配置面板 (SerialConfigPanel.tsx)

#### 自定义选择器组件
```typescript
const CustomSelect = ({ value, options, onChange, placeholder }: CustomSelectProps) => {
  const [isOpen, setIsOpen] = useState(false);
  const selectRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (selectRef.current && !selectRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  return (
    <div ref={selectRef} style={{ position: 'relative' }}>
      <div
        onClick={() => setIsOpen(!isOpen)}
        style={{
          width: '100%',
          padding: '8px 12px',
          border: `1px solid ${mdColors.outlineVariant}`,
          borderRadius: '6px',
          backgroundColor: 'white',
          cursor: 'pointer',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center'
        }}
      >
        <span style={{ color: selectedOption ? '#000' : '#a0aec0' }}>
          {selectedOption ? selectedOption.label : placeholder}
        </span>
        <span style={{ 
          transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)', 
          transition: 'transform 0.2s' 
        }}>
          ▼
        </span>
      </div>
      {isOpen && (
        <div style={{
          position: 'absolute',
          top: '100%',
          left: 0,
          right: 0,
          backgroundColor: 'white',
          border: `1px solid ${mdColors.outlineVariant}`,
          borderRadius: '6px',
          boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
          zIndex: 1000
        }}>
          {options.map((option) => (
            <div
              key={option.value}
              onClick={() => {
                onChange(option.value);
                setIsOpen(false);
              }}
              style={{
                padding: '8px 12px',
                cursor: 'pointer',
                backgroundColor: option.value === value ? '#f7fafc' : 'white'
              }}
            >
              {option.label}
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

#### 配置管理逻辑
```typescript
export const SerialConfigPanel = () => {
  const [config, setConfig] = useState<SerialConfig>({
    port: '',
    baudRate: 9600,
    dataBits: 8,
    stopBits: 1,
    parity: 'None',
    slaveID: 12,
  });

  const handleConfigUpdate = async (field: string, value: any) => {
    const newConfig = { ...config, [field]: value };
    setConfig(newConfig);
    
    try {
      const result = await UpdateSerialConfig(
        newConfig.port,
        newConfig.baudRate,
        newConfig.dataBits,
        newConfig.stopBits,
        newConfig.parity,
        newConfig.slaveID
      );
      
      if (result) {
        showToast(`${field} 已更新为 ${value}`, 'success');
      } else {
        showToast('更新配置失败', 'error');
      }
    } catch (error: any) {
      showToast(error.message || '更新配置失败', 'error');
    }
  };

  const handleSerialToggle = () => {
    if (isConnected) {
      updateStatus({ connected: false, errorMessage: '' });
      StopPolling().catch(console.error);
      showToast('数据采集已停止', 'success');
    } else {
      if (!config.port) {
        showToast('请先选择串口', 'error');
        return;
      }
      
      updateStatus({ connected: true, errorMessage: '' });
      StartPolling().then(result => {
        if (result) {
          showToast('数据采集已开始', 'success');
        } else {
          updateStatus({ connected: false, errorMessage: '启动失败' });
          showToast('启动数据采集失败', 'error');
        }
      }).catch(error => {
        updateStatus({ connected: false, errorMessage: error.message });
        showToast(error.message || '操作失败', 'error');
      });
    }
  };
};
```

### 4. 状态监控面板 (StatusPanel.tsx)

```typescript
export const StatusPanel = () => {
  const { status } = useAppStore();

  return (
    <Card.Root bg={mdColors.surface} shadow="md" borderRadius="xl">
      <Card.Header pb={2}>
        <Text fontSize="lg" fontWeight="bold" color={mdColors.onSurface}>
          设备状态
        </Text>
      </Card.Header>
      <Card.Body pt={2}>
        <VStack gap={4} align="stretch">
          {/* 连接状态 */}
          <HStack justify="space-between">
            <Text fontSize="sm">连接状态</Text>
            <Badge 
              bg={status.connected ? mdColors.secondaryContainer : mdColors.errorContainer}
              color={status.connected ? mdColors.onSecondaryContainer : mdColors.error}
            >
              {status.connected ? '已连接' : '未连接'}
            </Badge>
          </HStack>

          {/* 协议类型 */}
          <HStack justify="space-between">
            <Text fontSize="sm">协议类型</Text>
            <Badge bg={mdColors.primaryContainer} color={mdColors.onPrimaryContainer}>
              {status.protocol}
            </Badge>
          </HStack>

          {/* 错误信息 */}
          {status.errorMessage && (
            <Box>
              <Text fontSize="sm" color={mdColors.error} mb={1}>错误信息</Text>
              <Text 
                fontSize="xs" 
                color={mdColors.error} 
                bg={mdColors.errorContainer} 
                p={2} 
                borderRadius="md"
              >
                {status.errorMessage}
              </Text>
            </Box>
          )}
        </VStack>
      </Card.Body>
    </Card.Root>
  );
};
```

## 状态管理系统

### 1. 应用状态存储 (appStore.ts)

```typescript
interface DeviceStatus {
  connected: boolean;
  protocol: string;
  lastUpdate: string;
  errorMessage?: string;
}

interface ElectricalData {
  voltage: number;
  current: number;
  activePower: number;
  reactivePower: number;
  apparentPower: number;
  powerFactor: number;
  frequency: number;
  activeEnergy: number;
  timestamp: string;
}

class AppStore {
  private status: DeviceStatus = {
    connected: false,
    protocol: 'Modbus RTU',
    lastUpdate: new Date().toISOString(),
  };

  private data: ElectricalData | null = null;
  private listeners: Set<() => void> = new Set();
  private dataInterval: number | null = null;

  constructor() {
    this.startDataGeneration();
  }

  // 状态获取方法
  getStatus(): DeviceStatus {
    return { ...this.status };
  }

  getData(): ElectricalData | null {
    return this.data ? { ...this.data } : null;
  }

  // 状态更新方法
  updateStatus(newStatus: Partial<DeviceStatus>) {
    this.status = { ...this.status, ...newStatus, lastUpdate: new Date().toISOString() };
    this.notifyListeners();
  }

  // 订阅机制
  subscribe(listener: () => void) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  private notifyListeners() {
    this.listeners.forEach(listener => listener());
  }
}
```

### 2. 数据轮询逻辑

```typescript
private startDataGeneration() {
  this.dataInterval = window.setInterval(async () => {
    if (this.status.connected) {
      // 尝试获取真实数据
      let realData = null;
      try {
        const { GetElectricalData } = window.go?.main?.App || {};
        if (GetElectricalData) {
          realData = await GetElectricalData();
        }
      } catch (error) {
        realData = null;
      }
      
      if (realData && this.hasValidData(realData)) {
        // 使用真实数据
        this.data = {
          voltage: realData.voltage || 0,
          current: realData.current || 0,
          activePower: realData.activePower || 0,
          reactivePower: realData.reactivePower || 0,
          apparentPower: realData.apparentPower || 0,
          powerFactor: realData.powerFactor || 0,
          frequency: realData.frequency || 0,
          activeEnergy: realData.activeEnergy || 0,
          timestamp: realData.timestamp || new Date().toISOString(),
        };
      } else {
        // 使用模拟数据 (开发/演示用)
        this.data = this.generateMockData();
      }
      this.notifyListeners();
    }
  }, 1000);
}

private hasValidData(data: any): boolean {
  if (!data) return false;
  
  // 检查是否有任何非零数值
  return (
    (data.voltage && data.voltage > 0) ||
    (data.current && data.current > 0) ||
    (data.activePower && data.activePower !== 0) ||
    (data.frequency && data.frequency > 0)
  );
}
```

### 3. 自定义 Hook (usePolling.ts)

```typescript
export const useAppStore = () => {
  const [status, setStatus] = useState(appStore.getStatus());
  const [data, setData] = useState(appStore.getData());

  useEffect(() => {
    const unsubscribe = appStore.subscribe(() => {
      setStatus(appStore.getStatus());
      setData(appStore.getData());
    });

    return () => {
      unsubscribe();
    };
  }, []);

  return { status, data };
};

export const updateStatus = (newStatus: any) => {
  appStore.updateStatus(newStatus);
};
```

## 主题系统设计

### 1. Material Design 3 色彩系统 (colors.ts)

```typescript
// Material Design 3 色彩体系
export const mdColors = {
  primary: 'rgb(65 95 145)',
  primaryContainer: 'rgb(214 227 255)',
  onPrimaryContainer: 'rgb(40 71 119)',
  secondary: 'rgb(86 95 113)',
  secondaryContainer: 'rgb(218 226 249)',
  onSecondaryContainer: 'rgb(62 71 89)',
  background: 'rgb(249 249 255)',
  surface: 'rgb(249 249 255)',
  surfaceContainer: 'rgb(237 237 244)',
  onSurface: 'rgb(25 28 32)',
  onSurfaceVariant: 'rgb(68 71 78)',
  outline: 'rgb(116 119 127)',
  outlineVariant: 'rgb(196 198 208)',
  error: 'rgb(186 26 26)',
  errorContainer: 'rgb(255 218 214)',
  cardBackground: '#fffffe',
};

// 数据显示色彩
export const dataColors = {
  blue: '#3182ce',
  orange: '#dd6b20', 
  green: '#38a169',
  purple: '#805ad5',
  teal: '#319795',
  cyan: '#0bc5ea',
  pink: '#d53f8c',
  red: '#e53e3e',
};
```

### 2. 响应式设计

```typescript
// 响应式断点
const breakpoints = {
  base: '0px',    // 移动设备
  sm: '480px',    // 小屏幕
  md: '768px',    // 平板
  lg: '992px',    // 桌面
  xl: '1280px',   // 大屏幕
};

// 响应式网格
<SimpleGrid columns={{ base: 2, lg: 4 }} gap={6}>
  {/* 移动端 2 列，桌面端 4 列 */}
</SimpleGrid>

// 响应式布局
<Grid templateColumns={{ base: "1fr", lg: "2fr 1fr" }} gap={6}>
  {/* 移动端单列，桌面端双列 */}
</Grid>
```

## 用户交互设计

### 1. Toast 通知系统

```typescript
const Toast = ({ message, type, onClose }: ToastProps) => {
  const [isClosing, setIsClosing] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setIsClosing(true);
      setTimeout(onClose, 280);
    }, 3000);
    return () => clearTimeout(timer);
  }, []);

  const colors = {
    success: { bg: '#38a169', border: '#2f855a' },
    error: { bg: mdColors.error, border: '#c53030' },
    warning: { bg: '#dd6b20', border: '#c05621' }
  };

  return (
    <div
      style={{
        position: 'fixed',
        top: '20px',
        right: '20px',
        backgroundColor: colors[type].bg,
        color: 'white',
        padding: '12px 16px',
        borderRadius: '6px',
        boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)',
        zIndex: 9999,
        animation: isClosing ? 'slideOut 0.3s ease-in forwards' : 'slideIn 0.3s ease-out'
      }}
    >
      {message}
    </div>
  );
};
```

### 2. 动画效果

```typescript
// 卡片悬停动画
<Card.Root 
  _hover={{ shadow: "lg", transform: "translateY(-2px)" }}
  transition="all 0.2s"
>

// 下拉箭头旋转动画
<span style={{ 
  transform: isOpen ? 'rotate(180deg)' : 'rotate(0deg)', 
  transition: 'transform 0.2s' 
}}>
  ▼
</span>
```

### 3. 表单验证

```typescript
const handleSlaveIDChange = (value: string) => {
  setSlaveID(value.toUpperCase());
  if (!value.trim()) {
    showToast('请输入从站地址后再进行通信', 'warning');
  }
};

const validateSlaveID = (hexStr: string) => {
  const id = parseInt(hexStr, 16);
  if (!isNaN(id) && id > 0 && id < 256) {
    return true;
  } else {
    showToast('从站地址必须为 01-FF 之间的十六进制数字', 'error');
    return false;
  }
};
```

## Wails 集成

### 1. 后端方法绑定

```typescript
// wailsjs/go/main/App.d.ts
export function GetAvailablePorts(): Promise<string[]>;
export function GetElectricalData(): Promise<{[key: string]: any}>;
export function StartPolling(): Promise<boolean>;
export function StopPolling(): Promise<boolean>;
export function UpdateSerialConfig(
  port: string,
  baudRate: number,
  dataBits: number,
  stopBits: number,
  parity: string,
  slaveID: number
): Promise<boolean>;
```

### 2. 异步调用处理

```typescript
const handleSerialToggle = async () => {
  try {
    if (isConnected) {
      await StopPolling();
      showToast('数据采集已停止', 'success');
    } else {
      const result = await StartPolling();
      if (result) {
        showToast('数据采集已开始', 'success');
      } else {
        showToast('启动数据采集失败', 'error');
      }
    }
  } catch (error: any) {
    showToast(error.message || '操作失败', 'error');
  }
};
```

## 性能优化

### 1. 组件优化

```typescript
// 使用 React.memo 避免不必要的重渲染
const DataCard = React.memo(({ title, value, unit, color }: DataCardProps) => {
  // 组件实现
});

// 使用 useCallback 缓存回调函数
const handleConfigUpdate = useCallback(async (field: string, value: any) => {
  // 处理逻辑
}, [config]);
```

### 2. 状态更新优化

```typescript
// 批量状态更新
const updateMultipleFields = (updates: Partial<SerialConfig>) => {
  setConfig(prev => ({ ...prev, ...updates }));
};

// 防抖处理
const debouncedUpdate = useMemo(
  () => debounce((field: string, value: any) => {
    handleConfigUpdate(field, value);
  }, 300),
  []
);
```

### 3. 内存管理

```typescript
// 清理定时器
useEffect(() => {
  return () => {
    if (dataInterval) {
      clearInterval(dataInterval);
    }
  };
}, []);

// 清理事件监听器
useEffect(() => {
  const handleClickOutside = (event: MouseEvent) => {
    // 处理逻辑
  };
  document.addEventListener('mousedown', handleClickOutside);
  return () => document.removeEventListener('mousedown', handleClickOutside);
}, []);
```

## 构建和部署

### 1. Vite 配置 (vite.config.ts)

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  build: {
    outDir: 'dist',
    sourcemap: false,
    minify: 'terser',
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom'],
          ui: ['@chakra-ui/react', '@emotion/react']
        }
      }
    }
  }
})
```

### 2. TypeScript 配置 (tsconfig.json)

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

### 3. 构建脚本

```json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  }
}
```