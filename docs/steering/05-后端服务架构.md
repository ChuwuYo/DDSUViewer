# DDSUViewer 后端服务架构

## 后端架构概述

DDSUViewer 后端采用 Go 语言开发，基于 Wails v2 框架构建桌面应用。整体架构采用分层设计，通过清晰的模块划分实现高内聚、低耦合的代码结构。后端负责串口通信、Modbus 协议处理、数据采集和业务逻辑管理。

## 技术栈详情

### 核心技术
- **Go 1.23**: 主要编程语言，提供高性能并发处理
- **Wails v2**: 桌面应用框架，提供前后端通信桥梁
- **go.bug.st/serial**: 跨平台串口通信库
- **自研 Modbus RTU**: 针对 DDSU666 优化的协议实现

### 依赖管理
```go
module DDSUViewer

go 1.23.0

require (
    github.com/wailsapp/wails/v2 v2.10.2
    go.bug.st/serial v1.6.4
)
```

## 项目结构

```
DDSUViewer/
├── main.go                 # 程序入口点
├── app.go                  # Wails 应用层
├── internal/               # 内部包
│   ├── service/           # 业务服务层
│   │   └── service.go
│   ├── modbus/            # Modbus 协议实现
│   │   └── modbus.go
│   ├── serial/            # 串口通信层
│   │   └── serial.go
│   ├── registers/         # 寄存器定义和解析
│   │   └── registers.go
│   ├── poller/            # 数据轮询器
│   │   └── poller.go
│   └── parser/            # 数据解析器
│       └── parser.go
├── go.mod                 # Go 模块定义
└── wails.json            # Wails 配置文件
```

## 核心模块设计

### 1. 程序入口 (main.go)

```go
package main

import (
    "embed"
    "github.com/wailsapp/wails/v2"
    "github.com/wailsapp/wails/v2/pkg/options"
    "github.com/wailsapp/wails/v2/pkg/options/assetserver"
)

// Version 应用程序版本号，通过 ldflags 设置
var Version = "dev"

//go:embed all:frontend/dist
var assets embed.FS

func main() {
    // 创建应用实例
    app := NewApp()

    // 创建 Wails 应用
    err := wails.Run(&options.App{
        Title:  "DDSUViewer",
        Width:  1024,
        Height: 768,
        AssetServer: &assetserver.Options{
            Assets: assets,
        },
        BackgroundColour: &options.RGBA{R: 255, G: 255, B: 255, A: 1},
        OnStartup:        app.startup,
        Bind: []interface{}{
            app,
        },
    })

    if err != nil {
        println("Error:", err.Error())
    }
}
```

**设计特点**:
- 嵌入前端资源到二进制文件
- 版本号通过编译时 ldflags 注入
- 统一的错误处理机制

### 2. 应用层 (app.go)

```go
package main

import (
    "context"
    "log"
    "DDSUViewer/internal/service"
    goserial "go.bug.st/serial"
)

// App Wails 应用结构体
type App struct {
    ctx     context.Context
    service *service.Service
}

// NewApp 创建新的应用实例
func NewApp() *App {
    svc := service.NewService()
    return &App{
        service: svc,
    }
}

// startup 应用启动回调
func (a *App) startup(ctx context.Context) {
    a.ctx = ctx
    log.Printf("DDSUViewer 应用启动成功")
}

// GetAvailablePorts 获取可用串口列表 (Wails方法)
func (a *App) GetAvailablePorts() []string {
    ports, err := a.service.GetAvailablePorts()
    if err != nil {
        log.Printf("获取串口列表失败: %v", err)
        return []string{}
    }
    return ports
}

// GetElectricalData 获取电参量数据 (Wails方法)
func (a *App) GetElectricalData() map[string]interface{} {
    data := a.service.GetElectricalData()
    if data == nil {
        return nil
    }
    
    return map[string]interface{}{
        "voltage":       data.Voltage,
        "current":       data.Current,
        "activePower":   data.ActivePower,
        "reactivePower": data.ReactivePower,
        "apparentPower": data.ApparentPower,
        "powerFactor":   data.PowerFactor,
        "frequency":     data.Frequency,
        "activeEnergy":  data.ActiveEnergy,
        "timestamp":     data.Timestamp.Format("2006-01-02T15:04:05Z07:00"),
    }
}

// StartPolling 启动数据采集 (Wails方法)
func (a *App) StartPolling() bool {
    err := a.service.StartPolling()
    if err != nil {
        log.Printf("启动数据采集失败: %v", err)
        return false
    }
    return true
}

// StopPolling 停止数据采集 (Wails方法)
func (a *App) StopPolling() bool {
    err := a.service.StopPolling()
    if err != nil {
        log.Printf("停止数据采集失败: %v", err)
        return false
    }
    return true
}

// UpdateSerialConfig 更新串口配置 (Wails方法)
func (a *App) UpdateSerialConfig(port string, baudRate int, dataBits int, 
    stopBits int, parity string, slaveID int) bool {
    
    // 参数转换
    var sb goserial.StopBits
    if stopBits == 2 {
        sb = goserial.TwoStopBits
    } else {
        sb = goserial.OneStopBit
    }
    
    var p goserial.Parity
    switch parity {
    case "Even":
        p = goserial.EvenParity
    case "Odd":
        p = goserial.OddParity
    default:
        p = goserial.NoParity
    }
    
    config := &service.SerialConfig{
        Port:     port,
        BaudRate: baudRate,
        DataBits: dataBits,
        StopBits: sb,
        Parity:   p,
        SlaveID:  slaveID,
    }
    
    err := a.service.UpdateSerialConfig(config)
    if err != nil {
        log.Printf("更新串口配置失败: %v", err)
        return false
    }
    return true
}
```

**设计特点**:
- 薄应用层，主要负责参数转换和错误处理
- 所有业务逻辑委托给 Service 层
- 统一的日志记录
- 类型安全的参数转换

### 3. 业务服务层 (service/service.go)

```go
package service

import (
    "fmt"
    "strings"
    "sync"
    "time"
    "DDSUViewer/internal/poller"
    "DDSUViewer/internal/serial"
    goserial "go.bug.st/serial"
)

// Service 服务管理器
type Service struct {
    conn         *serial.Connection           // 串口连接
    poller       *poller.Poller             // 数据轮询器
    config       *SerialConfig              // 串口配置
    status       *DeviceStatus              // 设备状态
    lastData     *ElectricalData            // 最新数据
    mutex        sync.RWMutex               // 读写锁
    subscribers  map[string]chan *ElectricalData  // 数据订阅者
    statusSubs   map[string]chan *DeviceStatus    // 状态订阅者
}

// SerialConfig 串口配置
type SerialConfig struct {
    Port     string
    BaudRate int
    DataBits int
    StopBits goserial.StopBits
    Parity   goserial.Parity
    SlaveID  int
}

// DeviceStatus 设备状态
type DeviceStatus struct {
    Connected    bool
    Protocol     string
    LastUpdate   time.Time
    ErrorMessage string
}

// ElectricalData 电参量数据
type ElectricalData struct {
    Voltage       float64
    Current       float64
    ActivePower   float64
    ReactivePower float64
    ApparentPower float64
    PowerFactor   float64
    Frequency     float64
    ActiveEnergy  float64
    Timestamp     time.Time
}

// NewService 创建服务实例
func NewService() *Service {
    return &Service{
        config: &SerialConfig{
            Port:     "COM1",
            BaudRate: 9600,
            DataBits: 8,
            StopBits: goserial.OneStopBit,
            Parity:   goserial.NoParity,
            SlaveID:  12,
        },
        status: &DeviceStatus{
            Connected:  false,
            Protocol:   "Modbus RTU",
            LastUpdate: time.Now(),
        },
        subscribers: make(map[string]chan *ElectricalData),
        statusSubs:  make(map[string]chan *DeviceStatus),
    }
}
```

#### 核心业务方法

```go
// StartPolling 启动数据采集
func (s *Service) StartPolling() error {
    s.mutex.Lock()
    defer s.mutex.Unlock()

    if s.poller != nil && s.poller.IsRunning() {
        return nil // 已在运行
    }

    // 检查串口配置
    if s.config.Port == "" {
        err := fmt.Errorf("请选择串口")
        s.status.Connected = false
        s.status.ErrorMessage = err.Error()
        return err
    }

    // 创建串口连接
    serialConfig := serial.Config{
        Port:     s.config.Port,
        BaudRate: s.config.BaudRate,
        DataBits: s.config.DataBits,
        StopBits: s.config.StopBits,
        Parity:   s.config.Parity,
    }

    s.conn = serial.NewConnection(serialConfig)
    if err := s.conn.Open(); err != nil {
        s.status.Connected = false
        // 提供详细的错误信息
        if strings.Contains(err.Error(), "not found") {
            s.status.ErrorMessage = fmt.Sprintf("串口 %s 不存在，请检查设备连接", s.config.Port)
        } else if strings.Contains(err.Error(), "Access is denied") || strings.Contains(err.Error(), "busy") {
            s.status.ErrorMessage = fmt.Sprintf("串口 %s 被占用，请关闭其他程序后重试", s.config.Port)
        } else {
            s.status.ErrorMessage = fmt.Sprintf("打开串口失败: %v", err)
        }
        return fmt.Errorf(s.status.ErrorMessage)
    }

    // 创建轮询器
    s.poller = poller.NewPoller(s.conn, byte(s.config.SlaveID))
    if err := s.poller.Start(); err != nil {
        s.conn.Close()
        return err
    }

    s.status.Connected = true
    s.status.ErrorMessage = ""
    
    // 通知状态订阅者
    for _, ch := range s.statusSubs {
        select {
        case ch <- s.status:
        default:
            // 通道满时跳过
        }
    }

    // 启动数据监听
    go s.listenData()

    return nil
}

// StopPolling 停止数据采集
func (s *Service) StopPolling() error {
    s.mutex.Lock()
    defer s.mutex.Unlock()

    if s.poller != nil {
        s.poller.Stop()
        s.poller = nil
    }
    if s.conn != nil {
        s.conn.Close()
        s.conn = nil
    }

    s.status.Connected = false
    s.status.ErrorMessage = ""
    
    // 通知状态订阅者
    for _, ch := range s.statusSubs {
        select {
        case ch <- s.status:
        default:
            // 通道满时跳过
        }
    }
    
    return nil
}

// listenData 监听数据更新
func (s *Service) listenData() {
    dataChan := s.poller.GetDataChannel()
    for regData := range dataChan {
        // 转换数据类型
        data := &ElectricalData{
            Voltage:       float64(regData.Voltage),
            Current:       float64(regData.Current),
            ActivePower:   float64(regData.ActivePower),
            ReactivePower: float64(regData.ReactivePower),
            ApparentPower: float64(regData.ApparentPower),
            PowerFactor:   float64(regData.PowerFactor),
            Frequency:     float64(regData.Frequency),
            ActiveEnergy:  float64(regData.ActiveEnergy),
            Timestamp:     time.Now(),
        }

        s.mutex.Lock()
        s.lastData = data
        s.status.LastUpdate = time.Now()
        s.mutex.Unlock()

        // 广播给订阅者
        s.mutex.RLock()
        for _, ch := range s.subscribers {
            select {
            case ch <- data:
            default:
                // 通道满时跳过
            }
        }
        s.mutex.RUnlock()
    }
}
```

**设计特点**:
- 线程安全的状态管理
- 详细的错误信息提供
- 订阅者模式支持多客户端
- 资源自动清理机制

### 4. 数据轮询器 (poller/poller.go)

```go
package poller

import (
    "context"
    "fmt"
    "sync"
    "time"
    "DDSUViewer/internal/modbus"
    "DDSUViewer/internal/registers"
    "DDSUViewer/internal/serial"
)

// Poller 轮询器
type Poller struct {
    conn     *serial.Connection
    slaveID  byte
    running  bool
    mutex    sync.RWMutex
    ctx      context.Context
    cancel   context.CancelFunc
    dataChan chan *registers.ElectricalData
    lastData *registers.ElectricalData
    dataMutex sync.RWMutex
}

// NewPoller 创建轮询器
func NewPoller(conn *serial.Connection, slaveID byte) *Poller {
    return &Poller{
        conn:     conn,
        slaveID:  slaveID,
        dataChan: make(chan *registers.ElectricalData, 10),
    }
}

// Start 启动轮询
func (p *Poller) Start() error {
    p.mutex.Lock()
    defer p.mutex.Unlock()

    if p.running {
        return fmt.Errorf("轮询已在运行")
    }

    p.ctx, p.cancel = context.WithCancel(context.Background())
    p.running = true

    go p.pollElectricalData()
    go p.pollEnergyData()

    return nil
}

// Stop 停止轮询
func (p *Poller) Stop() {
    p.mutex.Lock()
    defer p.mutex.Unlock()

    if !p.running {
        return
    }

    p.cancel()
    p.running = false
}

// pollElectricalData 轮询电参量数据 (1秒周期)
func (p *Poller) pollElectricalData() {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-p.ctx.Done():
            return
        case <-ticker.C:
            data := p.readElectricalRegisters()
            if data != nil {
                select {
                case p.dataChan <- data:
                default:
                    // 通道满时丢弃旧数据
                }
            }
        }
    }
}

// pollEnergyData 轮询电能数据 (10秒周期)
func (p *Poller) pollEnergyData() {
    ticker := time.NewTicker(10 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-p.ctx.Done():
            return
        case <-ticker.C:
            p.readEnergyRegister()
        }
    }
}
```

#### 数据读取实现

```go
// readElectricalRegisters 读取电参量寄存器
func (p *Poller) readElectricalRegisters() *registers.ElectricalData {
    regData := make(map[uint16][]byte)

    // 从 0x2000 连读到 0x200F (8个地址×2寄存器=16个寄存器)
    data := p.readRegistersWithRetry(registers.RegVoltage, 16)
    if data != nil && len(data) >= 32 {
        // 解析各个数据点 (每个数据点占4字节)
        regData[registers.RegVoltage] = data[0:4]        // 0x2000
        regData[registers.RegCurrent] = data[4:8]        // 0x2002  
        regData[registers.RegActivePower] = data[8:12]   // 0x2004
        regData[registers.RegReactivePower] = data[12:16] // 0x2006
        regData[registers.RegApparentPower] = data[16:20] // 0x2008
        regData[registers.RegPowerFactor] = data[20:24]   // 0x200A
        // 跳过 0x200C (data[24:28]) - 保留地址
        regData[registers.RegFrequency] = data[28:32]     // 0x200E
    }

    parsedData := registers.ParseElectricalData(regData)
    
    // 保存最新数据用于电能更新
    p.dataMutex.Lock()
    if parsedData != nil {
        // 保留之前的电能值
        if p.lastData != nil {
            parsedData.ActiveEnergy = p.lastData.ActiveEnergy
        }
        p.lastData = parsedData
    }
    p.dataMutex.Unlock()
    
    return parsedData
}

// readRegistersWithRetry 带重试的寄存器读取
func (p *Poller) readRegistersWithRetry(startAddr uint16, quantity uint16) []byte {
    maxRetries := 3
    timeout := 200 * time.Millisecond

    for retry := 0; retry < maxRetries; retry++ {
        data, err := p.readRegisters(startAddr, quantity, timeout)
        if err == nil {
            return data
        }

        // 重试前等待一小段时间
        if retry < maxRetries-1 {
            time.Sleep(50 * time.Millisecond)
        }
    }

    return nil
}

// readRegisters 读取寄存器
func (p *Poller) readRegisters(startAddr uint16, quantity uint16, timeout time.Duration) ([]byte, error) {
    if !p.conn.IsOpen() {
        return nil, fmt.Errorf("串口未打开")
    }

    // 构造读取帧
    frame := modbus.BuildReadFrame(p.slaveID, startAddr, quantity)

    // 发送请求
    _, err := p.conn.Write(frame)
    if err != nil {
        return nil, fmt.Errorf("发送失败: %v", err)
    }

    // 读取响应
    buffer := make([]byte, 256)
    n, err := p.conn.ReadWithTimeout(buffer, timeout)
    if err != nil {
        return nil, fmt.Errorf("读取超时: %v", err)
    }

    // 解析响应
    response, err := modbus.ParseResponse(buffer[:n])
    if err != nil {
        return nil, fmt.Errorf("解析失败: %v", err)
    }

    return response.Data, nil
}
```

**设计特点**:
- 分层轮询策略 (电参量1秒，电能10秒)
- 智能重试机制
- 上下文控制的优雅停止
- 非阻塞数据通道

### 5. 串口通信层 (serial/serial.go)

```go
package serial

import (
    "fmt"
    "sync"
    "time"
    "go.bug.st/serial"
)

// Config 串口配置
type Config struct {
    Port     string
    BaudRate int
    DataBits int
    StopBits serial.StopBits
    Parity   serial.Parity
}

// Connection 串口连接
type Connection struct {
    port   serial.Port
    config Config
    mutex  sync.Mutex
    isOpen bool
}

// NewConnection 创建新的串口连接
func NewConnection(config Config) *Connection {
    return &Connection{
        config: config,
        isOpen: false,
    }
}

// Open 打开串口
func (c *Connection) Open() error {
    c.mutex.Lock()
    defer c.mutex.Unlock()

    if c.isOpen {
        return fmt.Errorf("串口已打开")
    }

    mode := &serial.Mode{
        BaudRate: c.config.BaudRate,
        DataBits: c.config.DataBits,
        Parity:   c.config.Parity,
        StopBits: c.config.StopBits,
    }

    port, err := serial.Open(c.config.Port, mode)
    if err != nil {
        return fmt.Errorf("打开串口失败: %v", err)
    }

    c.port = port
    c.isOpen = true
    return nil
}

// Close 关闭串口
func (c *Connection) Close() error {
    c.mutex.Lock()
    defer c.mutex.Unlock()

    if !c.isOpen {
        return nil
    }

    err := c.port.Close()
    c.isOpen = false
    return err
}

// Write 写入数据
func (c *Connection) Write(data []byte) (int, error) {
    c.mutex.Lock()
    defer c.mutex.Unlock()

    if !c.isOpen {
        return 0, fmt.Errorf("串口未打开")
    }

    return c.port.Write(data)
}

// ReadWithTimeout 带超时的读取
func (c *Connection) ReadWithTimeout(buffer []byte, timeout time.Duration) (int, error) {
    c.mutex.Lock()
    defer c.mutex.Unlock()

    if !c.isOpen {
        return 0, fmt.Errorf("串口未打开")
    }

    c.port.SetReadTimeout(timeout)
    return c.port.Read(buffer)
}

// IsOpen 检查串口是否打开
func (c *Connection) IsOpen() bool {
    c.mutex.Lock()
    defer c.mutex.Unlock()
    return c.isOpen
}

// GetAvailablePorts 获取可用串口列表
func GetAvailablePorts() ([]string, error) {
    ports, err := serial.GetPortsList()
    if err != nil {
        return nil, fmt.Errorf("获取串口列表失败: %v", err)
    }
    return ports, nil
}
```

**设计特点**:
- 线程安全的串口操作
- 超时控制机制
- 状态管理和检查
- 跨平台端口检测

## 并发控制设计

### 1. 读写锁使用

```go
type Service struct {
    mutex sync.RWMutex  // 保护共享状态
    // ...
}

// 读操作使用读锁
func (s *Service) GetElectricalData() *ElectricalData {
    s.mutex.RLock()
    defer s.mutex.RUnlock()
    return s.lastData
}

// 写操作使用写锁
func (s *Service) updateData(data *ElectricalData) {
    s.mutex.Lock()
    defer s.mutex.Unlock()
    s.lastData = data
}
```

### 2. 通道通信

```go
// 非阻塞发送
select {
case dataChan <- data:
    // 发送成功
default:
    // 通道满，丢弃数据
}

// 带超时的接收
select {
case data := <-dataChan:
    // 处理数据
case <-time.After(timeout):
    // 超时处理
}
```

### 3. 上下文控制

```go
func (p *Poller) pollElectricalData() {
    ticker := time.NewTicker(1 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-p.ctx.Done():
            return  // 优雅退出
        case <-ticker.C:
            // 执行轮询
        }
    }
}
```

## 错误处理策略

### 1. 分层错误处理

```go
// 底层错误包装
func (c *Connection) Open() error {
    port, err := serial.Open(c.config.Port, mode)
    if err != nil {
        return fmt.Errorf("打开串口失败: %w", err)
    }
    // ...
}

// 中层错误转换
func (s *Service) StartPolling() error {
    if err := s.conn.Open(); err != nil {
        if strings.Contains(err.Error(), "not found") {
            return fmt.Errorf("串口 %s 不存在，请检查设备连接", s.config.Port)
        }
        return err
    }
    // ...
}

// 上层错误记录
func (a *App) StartPolling() bool {
    err := a.service.StartPolling()
    if err != nil {
        log.Printf("启动数据采集失败: %v", err)
        return false
    }
    return true
}
```

### 2. 重试机制

```go
func (p *Poller) readRegistersWithRetry(startAddr uint16, quantity uint16) []byte {
    maxRetries := 3
    backoff := 50 * time.Millisecond

    for retry := 0; retry < maxRetries; retry++ {
        data, err := p.readRegisters(startAddr, quantity, timeout)
        if err == nil {
            return data
        }

        if retry < maxRetries-1 {
            time.Sleep(backoff)
            backoff *= 2  // 指数退避
        }
    }

    return nil
}
```

### 3. 资源清理

```go
func (s *Service) StopPolling() error {
    s.mutex.Lock()
    defer s.mutex.Unlock()

    // 确保资源被正确清理
    if s.poller != nil {
        s.poller.Stop()
        s.poller = nil
    }
    if s.conn != nil {
        s.conn.Close()
        s.conn = nil
    }

    return nil
}
```

## 性能优化

### 1. 内存池

```go
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 256)
    },
}

func (p *Poller) readRegisters(...) ([]byte, error) {
    buffer := bufferPool.Get().([]byte)
    defer bufferPool.Put(buffer)
    
    // 使用 buffer
}
```

### 2. 批量操作

```go
// 一次读取多个连续寄存器
data := p.readRegistersWithRetry(registers.RegVoltage, 16)
if data != nil && len(data) >= 32 {
    // 批量解析多个数据点
    regData[registers.RegVoltage] = data[0:4]
    regData[registers.RegCurrent] = data[4:8]
    // ...
}
```

### 3. 缓存机制

```go
type Service struct {
    lastData *ElectricalData  // 缓存最新数据
    // ...
}

func (s *Service) GetElectricalData() *ElectricalData {
    s.mutex.RLock()
    defer s.mutex.RUnlock()
    return s.lastData  // 直接返回缓存数据
}
```

## 日志和监控

### 1. 结构化日志

```go
import "log/slog"

func (s *Service) StartPolling() error {
    slog.Info("启动数据采集",
        "port", s.config.Port,
        "baudRate", s.config.BaudRate,
        "slaveID", s.config.SlaveID)
    
    // ...
    
    if err != nil {
        slog.Error("启动失败",
            "error", err,
            "port", s.config.Port)
        return err
    }
    
    slog.Info("数据采集启动成功")
    return nil
}
```

### 2. 性能指标

```go
type Statistics struct {
    TotalRequests   int64
    SuccessRequests int64
    FailedRequests  int64
    AvgResponseTime time.Duration
}

func (p *Poller) recordMetrics(start time.Time, err error) {
    duration := time.Since(start)
    
    if err != nil {
        atomic.AddInt64(&stats.FailedRequests, 1)
    } else {
        atomic.AddInt64(&stats.SuccessRequests, 1)
    }
    
    atomic.AddInt64(&stats.TotalRequests, 1)
    // 更新平均响应时间
}
```

### 3. 健康检查

```go
func (s *Service) HealthCheck() map[string]interface{} {
    s.mutex.RLock()
    defer s.mutex.RUnlock()
    
    return map[string]interface{}{
        "connected":    s.status.Connected,
        "lastUpdate":   s.status.LastUpdate,
        "errorMessage": s.status.ErrorMessage,
        "dataAge":      time.Since(s.status.LastUpdate).Seconds(),
    }
}
```

## 构建和部署

### 1. 构建脚本

```bash
#!/bin/bash

# 设置版本号
VERSION=${1:-"dev"}

# 构建应用
wails build -ldflags="-X main.Version=${VERSION}"

# 压缩构建 (可选)
# wails build -ldflags="-s -w -X main.Version=${VERSION}" -upx
```

### 2. 交叉编译

```bash
# Windows
GOOS=windows GOARCH=amd64 wails build

# Linux  
GOOS=linux GOARCH=amd64 wails build

# macOS
GOOS=darwin GOARCH=amd64 wails build
```

### 3. 配置管理

```go
type Config struct {
    LogLevel    string `json:"logLevel"`
    MaxRetries  int    `json:"maxRetries"`
    Timeout     int    `json:"timeout"`
}

func LoadConfig(path string) (*Config, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    
    var config Config
    err = json.Unmarshal(data, &config)
    return &config, err
}
```